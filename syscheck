#!/usr/bin/perl -w

use strict;
# this is disabled to give better cross-platform compatibility without excessive warnings from
# the perl interpreter.  
use warnings;
use feature qw( switch );
#print "PERLVER: $] \n";
use 5.010;
# perls prior to 5.18 don't consider the smartmatch feature "experimental, so it is a compile-time
# error.  The only option seems to be disabling warnings.
#no warnings "experimental::smartmatch";

use Term::ANSIColor;
use Data::Dumper;
use Getopt::Long qw( :config no_ignore_case bundling );

use YAML qw( LoadFile );
use MIME::Lite;

use LASObjects;
use LASObjects::Mount;

my ($help,$verbose,$config);
$verbose = 0;
GetOptions(
	'h|help'		=>	\$help,
	'v|verbose+'	=>	\$verbose,
	'c|config=s'	=>	\$config,
);

my ($free, $df, $sensors);
my %from_bool	= ('true'=>1, 'false'=>0);
my %to_bool	= (1=>'true', 0=>'false');
my %Sensor = (
	'id'		=>	'',
	'bus'		=>	'',
	'adapter'	=>	'',
	'node'		=>	'',
	'sensor'	=>	'',
	'temp'		=>	'',
);
my %HashOfSensors;

&usage if ($help);

if (scalar(@ARGV) > 1) {
	print colored("Only one action verb expected.  Got ".scalar(@ARGV).".\n", "bold red");
	&usage;
}

if (scalar(@ARGV) == 0) {
	print colored("At least one action verb expected.  Got 0. \n", "bold red");
	&usage;
}

if ((!defined($config)) or ($config eq "")) {
	print colored("You must specify a config file.  Otherwise, my output will be lost to the ether, and I don't like doing that. \n", "bold red");
	&usage;
}

our $CONFIG = &get_config($config);

print Dumper($CONFIG) if (($verbose)  and ($verbose > 1));

my $action = $ARGV[0];

given ($action) {
	when (/(?:mounts|fs|filesystems)/) {
		my $m_ref = &check_mounts;
		#print "RTV: $r \n";
		my $notgood = 0;
		foreach my $k ( sort keys %{$m_ref} ) {
			next if ($k eq 'total');
			next if ($k eq '_ALL_');
			$notgood++ if ($m_ref->{$k});
		}
		if ($notgood) {
			print "$notgood / $m_ref->{'_ALL_'} had issues. \n";
		} else {
			print colored("good. \n", "bold green");
		}
	}
	when (/memory/) {
		my $m_ref = &check_memory;
		#print Dumper($m_ref);
		my $notgood = 0;
		foreach my $k ( sort keys %{$m_ref} ) { 
			next if ($k eq 'total');
			next if ($k eq '_ALL_');
			$notgood++ if ($m_ref->{$k}); 
		}
		if ($notgood) {
			print "$notgood / $m_ref->{'_ALL_'} had issues.\n";
		} else {
			print colored("good. \n", "bold green");
		}
	}
	when (/temps/) {
		&check_temps;
	}
	default {
		die colored("Unrecognized action: $action \n", "bold red");
	}
}

###############################################################################
# Subs
###############################################################################
sub usage {
	print <<END;

Usage $0 [-h|--help] [-v|--verbose] [-c|--config] <config file> action

Where:

-h|--help			Displays this useful message, then exits.
-v|--verbose			Prints more verbose output.  Usually used for debugging.
-c|--config			Specifies the config file to use.  Cannot operate without
				a valid YAML config file.

ACTIONS are as follows:

memory				Check the memory and swap for usage data. Emails 
				notification if/when threashold reached.  Thresholds 
				specified in config file.
mounts|fs|filesystems		Check the filesystems for usage data.  Emails
				notification if/when threshold reached.  Thresholds
				specified in config file.

END

	exit 1;			# exit "true" in the absence of a true boolean
}

sub ltrim { my $s = shift(@_); $s =~ s/^\s+//;       return $s; }
sub rtrim { my $s = shift(@_); $s =~ s/\s+$//;       return $s; }
sub  trim { my $s = shift(@_); $s =~ s/^\s+|\s+$//g; return $s; }

sub get_config {
	my $config_file = shift(@_);

	my $config_ref = LoadFile($config_file);
	return $config_ref;
}

sub send_message {
	my $severity = shift(@_);
	my $app = shift(@_);

	my %sev = (
		1	=>	'notice',
		2	=>	'warning',
		3	=>	'critical'
	);

	if ($from_bool{$CONFIG->{'gmail'}}) {
		use Email::Send::SMTP::Gmail;

		my $msg = Email::Send::SMTP::Gmail->new(
			'-smtp'		=>	'gmail.com',
			'-login'	=>	$CONFIG->{'authuser'},
			'-pass'		=>	$CONFIG->{'authpass'},
		);

		$msg->send(
			'-to'		=>	$CONFIG->{'to'},
			'-subject'	=>	ucfirst($sev{$severity}).": ".ucfirst($app),
			'-verbose'	=>	0,
			'-body'		=>	"Your system (".$CONFIG->{'hostname'}.") has reached $sev{$severity} status of $app\.\n",
			'-attachments'	=>	''
		);

		$msg->bye;
	} else {
		MIME::Lite->send('smtp', $CONFIG->{'smtp-server'}, 'Debug'=>$from_bool{$CONFIG->{'smtp-debug'}});
		my $msg = MIME::Lite->new(
			'From'		=>	$CONFIG->{'from'},
			'To'		=>	$CONFIG->{'to'},
			'Cc'		=>	$CONFIG->{'cc'},
			'Subject'	=>	ucfirst($sev{$severity}).": ".ucfirst($app),
			'Data'		=>	"Your system (".$CONFIG->{'hostname'}.") has reached $sev{$severity} status of $app\.\n",
		);

		$msg->send;
	}

	return 1;
}

sub send_notice {
	my $app = shift(@_);
	&send_message(1, $app);

	return 1;
}

sub send_warning {
	my $app = shift(@_);
	&send_message(2, $app);

	return 1;
}

sub send_critical {
	my $app = shift(@_);
	&send_message(3, $app);

	return 1;
}

sub get_binary {
	my $bin = shift(@_);
	my $rtv = 1;

	my $bin_path = `which $bin`;
	chomp($bin_path);

	if ((!defined($bin_path)) or ($bin_path eq "")) {
		warn colored("Unable to find the `$bin` utility! \n", "yellow");
		return undef;
	} else {
		return $bin_path;
	}
}

sub check_mounts {
	my $rtv = 0;
	my $total_mounts = 0;
	my %mounts;

	my $df = &get_binary('df');
	die colored("Unabled to get `df` binary! \n", "bold red") if ((!defined($df)) or ($df eq ""));

	print colored("Checking mounts .... ", "bold green");
	open DF, "$df |" or die "There was a problem loading the df utility: $! \n";
	while (my $line = <DF>) {
		chomp($line);
		given ($line) {
			when (/Filesystem\s+/) {
				# skip the header
				next;
			}
			when (/^(?:none|udev|(?:dev)?tmpfs|shm|cgroup_root)/) {
				# don't really care about tmp filesystems
				next;
			}
			when (/(\/dev\/x?(?:[sv]d[a-f]\d|disk\/by-label\/DOROOT|mapper\/opt_crypt|dm\-\d))\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\%\s+(.*)/) {
				my $fs = $1; my $b = $2; my $u = $3; my $av = $4; my $p = $5; my $mnt = $6;
				my $mount = LASObjects::Mount->new($mnt, $fs);
				$total_mounts++;
				$mounts{"$fs\-$mnt"} = 0;

				#print Dumper($mount);
				if ($mount->{'calc_percent_free'} < 10) {
					print colored("\n$fs\: ".sprintf("%-3.4f%%", $mount->{'calc_percent_free'})." percent free \n", "yellow") if ($verbose);
					&send_warning($action);
					$mounts{"$fs\-$mnt"} += 2;
					$rtv--;
				} else { 
					$rtv++; 
					print colored("$fs\: ".sprintf("%-3.4f%%", $mount->{'calc_percent_free'})." percent free \n", "green") if ($verbose);
				}
			}
			# SMB/Network shares
			when (/(\/\/(?:\d{1,3}\.){3}\d{1,3}\/.*?\/?)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\%\s+(.*)/) {
				my $fs = $1; my $b = $2; my $u = $3; my $av = $4; my $p = $5; my $mnt = $6;
				my $mount = LASObjects::Mount->new($mnt, $fs);
				$total_mounts++;

				#print Dumper($mount);
				if ($mount->{'calc_percent_free'} < 10) {
					print colored("\n$fs\: ".sprintf("%-3.4f%%", $mount->{'calc_percent_free'})." percent free \n", "yellow") if ($verbose);
					&send_warning($action);
					$mounts{"$fs\-$mnt"} += 2;
					$rtv--;
				} else { 
					$rtv++; 
					print colored("$fs\: ".sprintf("%-3.4f%%", $mount->{'calc_percent_free'})." percent free \n", "green") if ($verbose);
				}
			}
			default {
				print "Line didn't match: \n";
				print "$line \n";
			}
		}
	}
	close DF or die "There was a problem closing the df utility: $! \n";

	$mounts{'_ALL_'} = $total_mounts;
	return \%mounts;
}

sub check_memory {
	my $free = &get_binary('free');
	die colored("Unable to get `free` bindary! \n", "bold red") if ((!defined($free)) or ($free eq ""));

	my $rtv = 0;
	my $total_mems = 0;
	my %mems;
	
	print colored("Checking memory ..... ", "bold green");
	open FREE, "$free -t |" or die "There was a problem loading the free utility: $! \n";
	while (my $line = <FREE>) {
		chomp($line);
		given ($line) {
			when (/total\s+used\s+free\s+shared\s+buffers\s+cached/) {
				# skip the headers
				next;
			}
			when (/total\s+used\s+free\s+shared\s+buff\/cache\s+available/) {
				# skip the headers
				next;
			}
			when (/\-\/\+ buffers\/cache\:\s+\d+\s+\d+/) {
				# skip the headers
				next;
			}
			when (/Mem:\s+(\d+)\s+(\d+)\s+(\d+).*/) {
				my $t = $1; my $u = $2; my $f = $3;
				my $p = ($f * 100) / $t;
				$total_mems++;
				$mems{'mem'} = 0;
				if (($p > 5) and ($p <= 10)) {
					print colored("Sending notice...\n", "bold yellow") if ($verbose);
					print colored(sprintf("Mem: %-3.2f%% free", $p)." \n", "bold yellow") if ($verbose);
					&send_notice($action);
					#print colored("notice. \n", "bold yellow");
					$mems{'mem'} = 1;
				} elsif (($p > 1) and ($p <= 5)) {
					print colored("Sending warning... \n", "yellow") if ($verbose);
					print colored(sprintf("Mem: %-3.2f%% free", $p)." \n", "yellow") if ($verbose);
					&send_warning($action);
					#print colored("warning. \n", "yellow");
					$mems{'mem'} = 2;
				} elsif ($p <= 1) {
					print colored("Sending critical.... \n", "bold red") if ($verbose);
					print colored(sprintf("Mem: %-3.2f%% free", $p)." \n", "bold red") if ($verbose);
					&send_critical($action);
					#print colored("critical. \n", "bold red");
					$mems{'mem'} = 3;
				} else {
					print colored("Within operational parameters... \n", "green") if ($verbose);
					print colored(sprintf("Mem: %-3.2f%% free", $p)." \n", "green") if ($verbose);
					#print colored("good. \n", "bold green");
				}
			}
			when (/Swap:\s+(\d+)\s+(\d+)\s+(\d+).*/) {
				my $t = $1; my $u = $2; my $f = $3;
				next if ($t == 0);
				my $p = ($f * 100) / $t;
				$total_mems++;
				$mems{'swap'} = 0;
				if (($p > 5) and ($p <= 10)) {
					print colored("Sending notice...\n", "bold yellow") if ($verbose);
					print colored(sprintf("Swap: %-3.2f%% free", $p)." \n", "bold yellow") if ($verbose);
					&send_notice($action);
					#print colored("notice. \n", "bold yellow");
					$mems{'swap'} = 1;
				} elsif (($p > 1) and ($p <= 5)) {
					print colored("Sending warning... \n", "yellow") if ($verbose);
					print colored(sprintf("Swap: %-3.2f%% free", $p)." \n", "yellow") if ($verbose);
					&send_warning($action);
					#print colored("warning. \n", "yellow");
					$mems{'swap'} = 2;
				} elsif ($p <= 1) {
					print colored("Sending critical.... \n", "bold red") if ($verbose);
					print colored(sprintf("Swap: %-3.2f%% free", $p)." \n", "bold red") if ($verbose);
					&send_critical($action);
					#print colored("critical. \n", "bold red");
					$mems{'swap'} = 3;
				} else {
					print colored("Within operational parameters... \n", "green") if ($verbose);
					print colored(sprintf("Swap: %-3.2f%% free", $p)." \n", "green") if ($verbose);
					#print colored("good. \n", "bold green");
				}
			}
			when (/Total:\s+(\d+)\s+(\d+)\s+(\d+).*/) {
				my $t = $1; my $u = $2; my $f = $3;
				my $p = ($f * 100) / $t;
				$mems{'total'} = 0;
				if (($p > 5) and ($p <= 10)) {
					print colored("Sending notice...\n", "bold yellow") if ($verbose);
					print colored(sprintf("Total: %-3.2f%% free", $p)." \n", "bold yellow") if ($verbose);
					&send_notice($action);
					#print colored("notice. \n", "bold yellow");
					$mems{'total'} = 1;
				} elsif (($p > 1) and ($p <= 5)) {
					print colored("Sending warning... \n", "yellow") if ($verbose);
					print colored(sprintf("Total: %-3.2f%% free", $p)." \n", "yellow") if ($verbose);
					&send_warning($action);
					#print colored("warning. \n", "yellow");
					$mems{'total'} = 2;
				} elsif ($p <= 1) {
					print colored("Sending critical.... \n", "bold red") if ($verbose);
					print colored(sprintf("Total: %-3.2f%% free", $p)." \n", "bold red") if ($verbose);
					&send_critical($action);
					#print colored("critical. \n", "bold red");
					$mems{'total'} = 3;
				} else {
					print colored("Within operational parameters... \n", "green") if ($verbose);
					print colored(sprintf("Total: %-3.2f%% free", $p)." \n", "green") if ($verbose);
					#print colored("good. \n", "bold green");
				}
			}
			default {
				# do nothing;
				print "Line didn't match! \n" if ($verbose);
				print "$line \n" if ($verbose);
			}
		}
	}
	close FREE or die "There was a problem closing the free utility: $! \n";

	$mems{'_ALL_'} = $total_mems;
	return \%mems;
}

sub check_temps {

	my $sensors = &get_binary('sensors');

	my $rtv = 0;
	my $total_sensors = 0;
	my %sensors;

	print colored("Checking temps....", "bold green");

	### TO DO:  Clean this up.  Use regex or grep to filter out available
	### sensor buses, then call each sensor bus individually.
	my $sensor_str = `$sensors -u`;
	chomp($sensor_str);

	my @sections = split(/\n\n/m, $sensor_str);
	#print Dumper(\@sections);

	my @objs;
	foreach my $sect ( @sections ) {
		my $sobj = LASObjects->sensor_parse($sect);
		print colored(Dumper($sobj), "bold green") if ($verbose);
		push @objs, $sobj;
		#if ($sobj->high_temp) {
		#	print colored("$sobj->{'name'} has high temp! \n", "bold yellow");
		#} else { print colored("good. \n", "bold green"); }
	}

	foreach my $o ( @objs ) {
		print "$o->{'adapter'}\: \n";
		foreach my $n ( keys %{$o->{'sensors'}} ) {
			print "N: $n \n" if ($verbose);
			if ($o->{'sensors'}{$n}->high_temp) {
				print colored("$n has high temp! \n", "yellow");
			} else { print colored("good. \n", "bold green"); }
		}
	}

	return 1;
}
